{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"MySql笔记","date":"2022-08-21T06:26:45.879Z","updated":"2022-08-21T06:27:45.513Z","comments":true,"path":"2022/08/21/MySql笔记/","link":"","permalink":"http://example.com/2022/08/21/MySql%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1、从8.0.1开始，function为保留字。2、从MySQL 8.0.17开始，对于整数数据类型，显示宽度属性已弃用;您应该期望在MySQL的未来版本中删除对它的支持。3、show warnings;语句查看警告详细信息。4、分组函数（count sum avg max min）一般和group by联合使用，并且都是在group by 语句执行结束之后才会执行的，当一条sql语句中没有group by 的话，整张表的数据会自成一组。5，SQL语句规则：分组函数不可以直接使用在where子句当中，因为group by 是在where执行之后才会执行的6，规则：当一条语句中有group by的话，select后面只能跟分组函数和参与分组的字段，例：select job avg(sal) from emp group by job;7，尽量在where后过滤数据，实在不行再用having过滤，比如 having avg(sal) &gt; 2000;8,一个完整的语句：select …from…where … group by… having… order by…9，查询当前使用的数据库 select database()10, 终止一条正在编写的语句，键入\\c11,查看其它库中的表 show tables from (otherDatabaseName)12.转义用斜杠13，当一个文件的扩展名是 .sql，并且该文件中编写了大量的sql语句，我们称这样的文件为sql脚本。直接使用source命令执行sql脚本，例如 source D：.…...….\\test.sql;14,SQL语句的分类： DQL(数据查询语言) ： 查询语句，凡是select语句都是DQL DML(数据操作语言) ：insert delete update ，对表中的数据进行增删改 DDL(数据定义语言) ：create drop alter ,对表结构的增删改 TCL(事务控制语言) ： commit提交事务，rollback回滚事务。（TCL中的T是Transaction） DCL(数据控制语言) ： grant授权、revoke撤销权限等15，在表的连接查询方面有一个现象被称为：笛卡尔积现象（笛卡尔乘积现象）笛卡尔积现象：当两张表进行连接查询的时候，没有任何条件限制，最终查询结果条数是两张表记录条数的乘积怎么避免：加条件进行过滤，例如select e.ename,d.dname from emp e , dept d where e.id &#x3D; d.id;（SQL92老语法，不用）(使用别名提高可读性，提高执行效率)SQL99语法：…A join B on 连接条件 where… SQL99语法结构更清晰：表的连接条件和后来的where条件分离了例如select e.ename,d.dname from emp e join dept d on e.deptno &#x3D; d.deptno16、自连接就是把一张表当作两张表，例如 找出每个员工的上级领导，并显示员工名和领导名思路：员工的领导编号&#x3D;领导的员工编号select a.ename as ‘员工名’,b.ename as ‘领导名’ from emp a inner join emp b on a.mgr &#x3D; b.empno;17、外连接是什么，和内连接有什么区别？内连接：假设A、B两张表进行内连接，凡是两张表能够匹配的记录查询出来，AB两张表没有主副之分。外连接：假设A、B两张表进行外连接，一张表为主表，一张表为副表，主要查询主表中的数据，捎带着查询副表，当副表中的数据没有和主表中的数据匹配上，副表自动模拟出NULL与之匹配。18、多表内外连接结合使用：select … … from …join … on…join..on…left join…on…19、本机IP：127.0.0.1 或 localhost 或者在局域网中的真实IP20、select语句嵌套select语句，被嵌套的select语句是子查询。子查询可以出现在哪里？ select..(select)…from..(select)…where..(select).21、limit是mysql特有的，取结果集中的部分数据。语法：limit startIndex,lengthstartIndex表示起始位置，0表示第一条数据；length表示取几个limit是最后执行的一个环节22、通用的标准分页sql?每页显示3条记录：第一页：0，3 第二页：3，3 第三页：6，3 第四页：9，3每页显示pageSize条记录：第pageNo页：（pageNo-1）*pageSize,pageSize23、表的复制：create table 表名 as select语句；将查询结果插入到一张表中（表结构要相同）：insert into 表名 select语句24、mysql提供主键值自增：例如id int primary key auto_increment25、外键可以为NULL。外键字段引用其他表的某个字段的时候，被引用的字段不一定是主键，但至少具有unique约束26、什么是事务（Transaction)? 一个事务是一个完整的业务逻辑单元，不可再分。和事务语句相关的语句只有DML语句。只要执行了commit提交事务或者rollback回滚事务，事务就结束。事务包括四大特性： A:原子性：事务是最小的工作单元，不可再分 B:一致性：事务必须保证多条DML语句同时成功或者同时失败 I:隔离性：事务A与事务B之间具有隔离 D:持久性：最终数据必须持久化到硬盘文件中，事务才算成功的结束关于事务之间的隔离性；mysql默认的事务隔离级别是：可重复读。 事务隔离性存在隔离级别，理论上隔离级别包括四个： 第一级别：读未提交（read uncommitted) 对方事务还没有提交，我们当前事务可以读取到对方未提交的数据。读未提交存在脏读（Dirty Read） 现象：表示读到了脏的数据。 第二级别：读已提交（read committed） 这种隔离级别解决了：脏读现象。 对方事务提交之后的数据我方可以读取到。存在的问题是：不可重复读。 第三级别：可重复读（repeatable read） 这种隔离级别解决了：不可重复读问题。 存在的问题：读取到的数据是幻象。 第四级别：序列化读&#x2F;串行化读（serializable) 效率低，需要事务排队27、mysql事务默认情况下是自动提交的。只要执行任意一条DML语句则提交一次。怎么关闭自动提交？start transaction;28、设置事务的全局隔离级别：set global transaction isolation level read uncommitted;查看事务的全局隔离级别：select @@global.tx_isolation;29、将数据库中的数据导出（整个库）：在dos命令窗口执行：mysqldump bjpowernode&gt;D:\\bjpowernode.sql -uroot -p123导出指定的某个表：mysqldump bjpowernode 表名&gt;D:\\bjpowernode.sql -uroot -p12330、数据库设计三范式（按照这个三范式设计的表不会出现数据冗余）第一范式：任何一张表都应该有主键，并且每一个字段原子性不可再分第二范式：所有非主键字段完全依赖主键，不能产生部分依赖。解决方法：多对多、三张表、关系表中有两个外键第三范式：所有非主键字段直接依赖主键，不能产生传递依赖。解决方法：一对多、两张表、多的表加外键注意：在实际的开发中，以满足客户的需求为主，有时候会拿冗余换执行速度。31、一对一设计有两种方案：主键共享（有一个表的主键也是外键）、外键唯一（unique就是一对一，不唯一就是一对多）32、完美卸载mysql，双击安装包，remove，然后删除Program Files和ProgramData中的MysqlMySQL不是数据库（DB）,而是数据库管理系统（DBMS）","categories":[],"tags":[]}],"categories":[],"tags":[]}